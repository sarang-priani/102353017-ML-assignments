# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12fmZAVGMJhahgWKe_x4VdcboW0QEI5n3
"""

import pandas as pd
df=pd.read_csv('/AWCustomers.csv')
# Part I (a) - Feature Selection
# Drop columns that are irrelevant or mostly empty such as IDs, names, addresses, and sparse columns
cols_to_drop = [
    'CustomerID', 'Title', 'FirstName', 'MiddleName', 'LastName', 'Suffix',
    'AddressLine1', 'AddressLine2', 'PhoneNumber', 'PostalCode', 'LastUpdated'
]

df_reduced = df.drop(columns=cols_to_drop)

# Select columns relevant for predicting bike buyers based on their influence on purchase behavior
selected_columns = [
    'BirthDate', 'Education', 'Occupation', 'Gender', 'MaritalStatus', 'HomeOwnerFlag',
    'NumberCarsOwned', 'NumberChildrenAtHome', 'TotalChildren', 'YearlyIncome',
    'City', 'StateProvinceName', 'CountryRegionName'
]

df_selected = df_reduced[selected_columns]

print(df_selected.head())

# Part I (c) - Data Value Types for Selected Attributes
"""
Attribute           : Data Type   : Scale Type         : Explanation
---------------------------------------------------------------------------
BirthDate           : Continuous : Interval (date)    : Date values, can calculate Age
Education           : Discrete   : Ordinal            : Education levels with natural order
Occupation          : Discrete   : Nominal            : Job categories, no inherent order
Gender              : Discrete   : Nominal            : Categories: Male, Female
MaritalStatus       : Discrete   : Nominal            : Categories like Married, Single
HomeOwnerFlag       : Discrete   : Nominal (binary)   : Binary flag represented as 0 or 1
NumberCarsOwned     : Discrete   : Ratio              : Count of cars owned (0 or more)
NumberChildrenAtHome: Discrete   : Ratio              : Number of children currently at home
TotalChildren       : Discrete   : Ratio              : Total number of children
YearlyIncome        : Continuous : Ratio              : Annual income in currency units
City                : Discrete   : Nominal            : Names of cities
StateProvinceName   : Discrete   : Nominal            : Names of states/provinces
CountryRegionName   : Discrete   : Nominal            : Names of countries
"""

from sklearn.preprocessing import MinMaxScaler, StandardScaler, KBinsDiscretizer


# Convert BirthDate to Age and drop BirthDate
df_selected['BirthDate'] = pd.to_datetime(df_selected['BirthDate'])
today = pd.to_datetime('today')
df_selected['Age'] = (today - df_selected['BirthDate']).dt.days // 365
df_selected.drop('BirthDate', axis=1, inplace=True)

# Handle null values
for col in df_selected.columns:
    if df_selected[col].isnull().sum() > 0:
        if df_selected[col].dtype == 'O':
            df_selected[col].fillna('Unknown', inplace=True)
        else:
            df_selected[col].fillna(df_selected[col].median(), inplace=True)

# Numeric columns including Age
numeric_cols = ['Age', 'NumberCarsOwned', 'NumberChildrenAtHome', 'TotalChildren', 'YearlyIncome']

# Normalize numeric columns
scaler_minmax = MinMaxScaler()
df_selected[numeric_cols] = scaler_minmax.fit_transform(df_selected[numeric_cols])

# One-hot encode categorical columns
categorical_cols = ['Education', 'Occupation', 'Gender', 'MaritalStatus',
                    'City', 'StateProvinceName', 'CountryRegionName']
df_processed = pd.get_dummies(df_selected, columns=categorical_cols)

# Standardize numeric columns
scaler_std = StandardScaler()
df_processed[numeric_cols] = scaler_std.fit_transform(df_processed[numeric_cols])

# Discretize numeric columns into 5 bins
kbd = KBinsDiscretizer(n_bins=5, encode='ordinal', strategy='uniform')
df_processed[numeric_cols] = kbd.fit_transform(df_processed[numeric_cols])

# Convert boolean columns from one-hot encoding to int (0/1)
bool_cols = df_processed.select_dtypes(include='bool').columns
df_processed[bool_cols] = df_processed[bool_cols].astype(int)

print(df_processed.head())

#q3
from sklearn.metrics import jaccard_score
from sklearn.metrics.pairwise import cosine_similarity

cust1 = df_processed.iloc[0]
cust2 = df_processed.iloc[1]

numeric_features = ['Age', 'NumberCarsOwned', 'NumberChildrenAtHome', 'TotalChildren', 'YearlyIncome']
binary_features = [col for col in df_processed.columns if col not in numeric_features]

matches = (cust1[binary_features] == cust2[binary_features]).sum()
sms = matches / len(binary_features)

cust1_bin = cust1[binary_features].astype(int)
cust2_bin = cust2[binary_features].astype(int)
jaccard = jaccard_score(cust1_bin, cust2_bin)

cos_sim = cosine_similarity([cust1[numeric_features]], [cust2[numeric_features]])[0][0]

print(f"Simple Matching Similarity: {sms}")
print(f"Jaccard Similarity: {jaccard}")
print(f"Cosine Similarity: {cos_sim}")

if 'CommuteDistance' in df_processed.columns:
    corr = df_processed['CommuteDistance'].corr(df_processed['YearlyIncome'])
    print(f"Correlation between CommuteDistance and YearlyIncome: {corr}")
else:
    print("CommuteDistance not in dataset.")